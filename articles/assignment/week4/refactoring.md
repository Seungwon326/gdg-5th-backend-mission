# 4주차 학습 내용

## 예외처리
### 체크 vs 언체크 예외

- 체크 예외
    - 처리 여부가 강제됨 → 반드시 `try-catch`로 잡거나 `throws`로 던져야 함
    - 트랜잭션: 기본적으로 롤백 안 함
    - ex) `IOException`, `SQLException`
- 언체크 예외
    - 강제되지 않음 → 명시적인 처리가 없어도 컴파일 됨
    - 트랜잭션: 기본적으로 롤백 함
    - ex) `NullPointerException`, `IllegalArgumentException`
    - Spring에서 비즈니스 로직 실패 시 데이터를 원상복구(롤백)하려면, 사용자 정의 예외는 반드시 `RuntimeException`을 상속받아 언체크 예외로 만들어야 함
    - ResponseStatusException → 스프링이 **웹 브라우저(프론트엔드)에게 특정 HTTP 상태 코드를 전달**하기 위해 만든 전용 예외
      - new ResponseStatusException(상태코드, 메시지) 형식
      - 상태코드
          - 400 → BAD_REQUEST
              - 재고가 부족한데 주문했을 때, 가격을 마이너스로 입력했을 때
          - 404 → NOT_FOUND
              - 상품 조회, 삭제하려는데 해당 이름의 상품이 없을 때
          - 409 → CONFICT
              - 이미 ‘사과’가 있는데 또 '사과'를 등록하려 할 때

### 비즈니스 vs 시스템 예외

- 비즈니스 예외
    - 시스템은 정상 동작했지만, 사용자의 요청이 업무 규칙에 위배될 때 발생하는 예외 → 개발자가 의도적으로 발생 시키는 예외
    - ex) “잔액이 부족합니다.”, “비밀번호가 틀렸습니다.”
    - HTTP 상태: 주로 `400 Bad Request`, `404 Not Found`, `409 Conflict` 등을 반환
- 시스템 예외
    - 프로그램 로직이나 인프라 문제로 인해 예기치 않게 발생하는 예외 → 개발자가 의도하지 않았으며, 복구가 불가능한 경우가 많음
    - ex) 데이터베이스 연결 실패, 메모리 공간 부족
    - HTTP 상태: 주로 `500 Internal Server Error`를 반환

### 전역 예외 처리 방식

- @**RestControllerAdvice**
    - 여러 컨트롤러에 대해 전역적으로 **ExceptionHandler**를 적용해 줌 → JSON 형식으로 응답
- 장점
    - **Controller**에서 예외를 직접 처리하지 않아도 됨
    - 예외에 따라 다른 처리 로직을 적용할 수 있음
    - 공통적인 예외 처리 로직 재사용

## AOP
- 관점 지향 프로그래밍
    - ex) @RestControllerAdvice → 핵심 비즈니스 로직(컨트롤러) 건드리지 않고, 예외 처리라는 공통 기능을 분리
- AOP는 여러 모듈에 걸쳐 공통적으로 필요한 기능(= 횡단 관심사)을 별도의 클래스로 관리
- 핵심 용어
    - Target: 부가 기능(AOP)을 적용할 대상 객체 (주로 Service, Controller)
        - ex) 햄버거 패티(핵심)
    - Aspect: 횡단 관심사를 모듈화한 것
        - ex) 레시피 전체
    - Advice: 실질적으로 어떤 일을 해야 할지(로그 출력 등)에 대한 구현체, 실행 시점도 정의
        - ex) 부가 재료 → 핵심 재료를 감싸거나 보조해주는 역할
            - 로그 남기기, 트랜잭션 등
    - JoinPoint: AOP를 적용할 수 있는 모든 지점(매서드 실행 시점)
        - ex) 끼워 넣을 수 있는 틈새 들
    - Pointcut: JoinPoint 중에서 실제로 AOP를 적용할 지점을 선별하는 조건식
        - ex) ‘패티 위에만 소스를 뿌려야한다’라는 규칙
    - Weaving: Target의 코드에 Aspect를 실제로 적용하는 과정
        - ex) 조립하는 행위
- Spring AOP 동작 방식
    - 컴파일 시점에 코드를 수정하는 것이 아니라, 런타임에 '프록시(대리자)' 객체를 생성**하여 동작
        - 프록시 생성: Spring은 AOP가 적용된 클래스(Target)를 감싸는 가짜 객체(Proxy) 생성
        - 요청 가로채기: 클라이언트가 메서드를 호출하면, 실제 Target이 아니라 Proxy가 먼저 호출
        - 부가 기능 수행: Proxy는 `Advice`(로그, 트랜잭션 등)를 먼저 실행
        - 실제 로직 수행: 그 후 실제 `Target` 객체의 메서드를 호출(`proceed()`)
    - AOP가 적용된 메서드 안에서 자신의 다른 메서드(this.method())를 호출하면 AOP가 먹히지 않음 →  프록시를 거치지 않고 직접 호출해버리기 때문
- 공통 관심사 분리 → 단일 책임 원칙
    - 로깅, 성능 측정, 트랜잭션

## 리팩토링 원칙
- 리팩토링: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
    - 목표 : 코드의 복잡성 감소, 가독성 향상, 유지 보수성을 개선, 확장성을 높임
    - 금지 : 기능 변경/추가, 버그 수정, 성능 개선, 버전 업데이트
- 핵심 원칙 5가지
    1. 두 개의 모자
        - 기능 추가의 모자 (Function Addition):
            - 목표: 새로운 기능을 덧붙이는 것
            - 행동: 기존 코드가 지저분하더라도 건드리지 않고 오로지 테스트를 통과하는 새 기능을 만드는 데만 집중
        - 리팩토링의 모자 (Refactoring):
            - 목표: 코드의 구조를 개선하는 것
            - 행동: 기능을  절대 추가하지 않고 오직 코드 재구성에만 집중. 테스트 케이스도 새로 만들지 않고, 기존 테스트가 통과하는지만 확인
    2. 믿을 수 있는 테스트
        - 완벽한 테스트 코드가 없다면 리팩토링을 시작하지 않음
    3. 작은 단계
        - 리팩토링 과정을 아주 작은 단계로 쪼개서 진행
    4. 3의 법칙
        - 처음에는 그냥 한다: 기능 구현에 집중함
        - 두 번째로 비슷한 일을 하게 되면: 중복이 생겨도 일단은 그냥 함
        - 세 번째로 비슷한 일을 하게 되면: 그때 리팩토링 진행
    5. 보이스카우트 규칙
        - 처음 코드를 작성할때 리팩토링까지 완료하기
# 2주차 WIL

## 관심사 분리
- 컴퓨터 프로그램을 구별된 부분으로 분리시키는 디자인 원칙
    - 컴퓨터 프로그램을 여러 개의 고유한 기능을 가진 섹션으로 나누고, 각 섹션이 자신만의 관심사를 처리하도록 설계하는 것
    - 정보를 잘 정의된 인터페이스가 있는 코드 부분 안에 캡슐화시킴으로써 달성
- 필요성
    - 코드의 단순화 및 유지 보수의 더 높은 수준의 자유, 재사용성 증가
- 1주차에 작성한 Controller 계층 코드를 Service 계층과 나눔
    - `ProductController.java` → 오직 HTTP 통신만 관심
    - `ProductService.java` → 오직 비즈니스 로직만 관심

## 서비스 계층
- 비즈니스 로직을 처리하는 계층
- 비즈니스 로직
    - 애플리케이션이 "실제로 해야 하는 일"
    - (예: "상품을 등록한다", "회원 등급에 따라 할인율을 10% 또는 20%로 계산한다")
- 데이터 가공 및 조립
    - `Controller`는 클라이언트가 요청한 `DTO`를 그대로 전달
    - `Service`는 이 `DTO`를 DB에 저장할 수 있는 `Domain(Entity)` 객체로 변환
    - 반대로 `Repository`에서 `Entity`를 조회해오면, 이걸 클라이언트에게 보여줄 `DTO`로 변환해서 `Controller`에게 돌려줌
- 작업 조율 - 하나의 비즈니스 로직을 위해 여러 Repository를 호출
- 트랜잭션 관리 - 모두 성공하거나, 아니면 모두 실패(원상복구)해야 하는 하나의 작업 묶음

## Layered Architecture
- 소프트웨어 시스템을 관심사 별로 여러개의 계층으로 분리한 아키텍처
## 결합도와 응집도
- 결합도: "하나의 모듈이 다른 모듈과 얼마나 강하게 연결(의존)되어 있는가"를 나타내는 척도
- 응집도: "하나의 모듈이 하나의 목적을 수행하기 위해 얼마나 똘똘 뭉쳐있는가"를 나타내는 척도
- -> 응집도는 높게, 결합도는 낮게

## MVC 패턴
- Model (모델), View (뷰), Controller (컨트롤러)라는 세 가지 핵심 역할로 코드를 분리하는 방식
    - Model(모델)
        - 애플리케이션의 **핵심 데이터**와 **비즈니스 로직**을 모두 담당
      
    - View(뷰)
        - 사용자에게 보여지는 화면(User Interface)
        - `Model`로부터 받은 데이터를 사용자에게 보여주는 역할
    - Controller(컨트롤러)
        - `Model`과 `View` 사이에서 모든 상호작용을 조율하는 중간 관리자

## 객체지향
- 객체 - 현실 세계의 '사물'이나 '개념'을 '객체(Object)'라는 단위로 보고, 이 객체들 간의 상호작용으로 프로그램을 설계하는 방식
    - 어떤 독립적인 하나의 개체(객체 하나로 어떤 기능을 수행)
    - 설계도를 만들고(→ 정보와 기능 정의) 객체를 생성함(→ 설계도를 바탕으로 만들어진 사물)

### 1주차 명세서 객체로 구분
#### 재고 객체

- 책임 → 재고 수량 스스로 변경 가능
    - 재고 검색 시 객체 정보 반환
    - 재고 구매 시 수량 감소
    - 재고 추가 시 수량 추가

#### 관리자 객체

- 책임 → 재고 객체에 대한 정보를 가지고 있고 소비자의 요청을 받아 처리
    - 재고 검색 시 재고 객체에서 조건에 맞는 재고 찾아서 반환
    - 재고 구매 시 해당 재고의 객체를 찾아 수량 감소 기능 호출
    - 재고 등록 시 새로운 재고 객체 생성
    - 재고 추가 시 해당 재고 객체에 수량 추가 기능 호출
    - 물품 삭제 시 재고 객체에서 해당 재고 객체 삭제

#### 소비자 객체

- 책임 → 특정 기능을 요청하는 주체
    - 재고 검색 요청
    - 재고 구매 요청


#### 협력 과정

1. 소비자 객체가 필요한 요청을 관리자 객체에게 요청
2. 관리자 객체는 소비자 객체의 요청을 재고 객체에게 전달(검색/구매/추가) 또는 직접 요청 수행(등록/삭제)
3. 재고 객체는 전달받은 요청을 수행
4. 재고 객체의 처리가 완료되면 관리자 객체는 사용자 객체에게 처리 완료 응답을 보냄

## 2주차 느낀점
서비스 계층을 공부하면서 1주차에 작성했던 코드를 수정했다. 기존에는 명세서에 적혀있는 예시를 입력받고 출력하는 고정 데이터를 다뤘는데 내가 임의의 데이터를 넣어도 처리가 가능하도록 수정하려고 했다. 우선 내가 어떤 비즈니스 로직을 원하는지 정확하게 파악해 정리 하고 나서 이를 위한 코드를 작성하려고 했다. 로직을 구현하는데 막힌 부분이 있어 시간이 오래 걸렸지만 새롭게 코드를 작성하고 swagger로 과정을 직접 확인해보니 각 계층의 역할과 계층간 소통 과정을 좀 더 이해할 수 있었다.
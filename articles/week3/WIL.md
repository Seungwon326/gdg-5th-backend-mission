# ORM

- 프로그래밍 언어의 '객체'와 데이터베이스의 '표'를 자동으로 연결(번역)해주는 도구(자동 번역기)
- 왜 필요한가?
    - 개발자(Java) - 객체지향 방식 사용
    - 데이터베이스(SQL) - 관계형 방식 사용
- 설정 방법(in JPA) → @Entity 어노테이션 추가
    - JPA - 자바 ORM을 위한 표준 설명서(규칙)
    - HIbernates - JPA라는 규칙(설명서)을 따르면서 실제로 ORM 기능을 구현한 실체
- ex
    - 객체 -> SQL (저장/수정/삭제 시):
    개발자가 `user.setName("B")`처럼 객체를 변경하고 `save(user)`라고 명령하면, ORM이 이걸 알아서 `UPDATE users SET name = 'B' WHERE ...` 같은 SQL로 번역해서 DB에 전달
    - SQL -> 객체 (조회 시):
    개발자가 `findUserById(1)`라고 객체를 찾는 메서드를 호출하면, ORM이 `SELECT * FROM users WHERE id = 1` 같은 SQL을 만들고, DB가 돌려준 데이터(표)를 받아서, 개발자가 쓰기 편하게 `User` 객체 형태로 다시 조립해서 돌려줌

# 영속성 컨텍스트

- EntityManagerFactory - Entity Manager를 만들고 구성하는법을 제공하는 interface
- EntityManager - DB table과 mapping된 객체인 Entity에 대한 CRUD 작업을 수행하기 위한 method들을 제공 및 Entity의 라이프 사이클과 영속성 관리등을 담당
    - JPA: 자바 ORM을 위한 표준 설명서(규칙)
    - Hibernate: 그 설명서를 보고 만든 공장(구현체)
    - 엔티티 매니저: 그 공장에서 실제로 물건(엔티티)을 창고(DB)에 넣고 빼는 일을 하는 현장 총괄 매니저
- 엔티티 매니저는 영속성 컨텍스트를 관리함
    - CRUD 실행
        - **`persist(entity)`:** 저장
        - **`find(Entity.class, id)`:** 조회
        - **`remove(entity)`:** 삭제
        - **`merge(entity)`:** 수정/병합
    - 1차 캐시
        - DB에서 한 번 불러온 객체를 1차 캐시에 올려두고 그 객체가 다시 필요 할 떄 DB에서 찾는게 아닌 1차 캐시에서 반환함
        - DB에서 불러오기 vs 1차 캐시에서 불러오기 → 집 밖 편의점(DB) 가기 vs 내 주머니(메모리)에서 물건 꺼내기
    - 쓰기 지연
        - SQL 명령을 받는 즉시 DB에 보내지 않고, 모아두었다가 모든 작업이 끝나고 트랜잭션이 `커밋(Commit)`되는 순간 한번에 DB로 보냄
    - 변경 감지
        - `save`나 `update` 같은 메서드를 부르지 않아도 수정된 걸 알아서 반영
- 영속성 컨텍스트(Persistence Context)
    - entity의 영속화에 관여하며 entity들이 DB로 바로 가지 않고 entity를 저장하는 환경으로서의 역할을 수행
    - 장점
        - 성능 향상 - DB 접근과 로드를 줄임
        - 데이터 일관성의 향상 - 엔티티가 일관성있도록 보장
    - JPA의 핵심 목적은 이 영속성 컨텍스트에 있는 엔티티의 상태와 데이터베이스의 상태를 일치시키 것
- EntityManger를 통해서 영속성 컨텍스트에 접근
    - EntityManager.persist(entity);
- 엔티티의 4가지 상태
1. 비영속 (New / Transient):
    - `User user = new User();`
    - 방금 `new`로 생성한 순수한 자바 객체 상태.
    - JPA(영속성 컨텍스트)가 이 객체의 존재를 전혀 모르고 DB와도 아무 관련이 없음
2. 영속 (Managed):
    - `em.persist(user);` 또는 `User user = em.find(...);`
    - 엔티티 매니저가 이 객체를 관리하기 시작한 상태
    - 이 상태의 엔티티는 영속성 컨텍스트(1차 캐시)에 보관
    - JPA의 마법(변경 감지, 쓰기 지연 등)은 오직 '영속' 상태의 엔티티에게만 일어남
3. 준영속 (Detached):
    - `em.detach(user);` 또는 `em.close();`
    - 과거에는 '영속' 상태였지만, 지금은 영속성 컨텍스트가 관리를 포기한(쫓아낸) 상태.
    - 더 이상 1차 캐시에 없으므로, 이 객체의 값을 아무리 바꿔도 JPA는 모름 (변경 감지가 동작하지 않음)
4. 삭제 (Removed):
    - `em.remove(user);`
    - 영속성 컨텍스트와 DB에서 모두 제거하기로 예약된 상태
    - 트랜잭션이 커밋되면 실제 `DELETE` SQL이 실행
- Transaction-Scoped
    - 영속성 컨텍스트는 트랜잭션이 시작될 때" 새로 생성되고 트랜잭션이 끝날 때 영속성 컨텍스트가 사라짐
- Extended-Scoped
    - 영속성 컨텍스트가 여러 트랜잭션에 걸쳐서 살아남음
- PC는 식별자를 Key로 엔터티를 Value로 보관하는 Map이기 때문에, 식별자를 통한 조회를 하지 않는다면 매번 DB에서 조회하게 됨
    - ex ‘username’으로만 두 번 호출 → SELECT문 두 번 발생

# Repository 계층

- 데이터베이스(DB)와 대화하는 유일한 창구 역할 수행
    - 개발자가 SQL 쿼리 문을 작성하지 않아도 자바 코드로 데이터를 저장하고 꺼내올 수 있음
    - 기본적인 CRUD 자동화
        - **C**reate (생성): `save()`
        - **R**ead (조회): `findById()`, `findAll()`
        - **U**pdate (수정): `save()`
        - **D**elete (삭제): `delete()`
    - 비즈니스 로직과 분리
- `@Entity`: DB 테이블과 1:1로 매핑될 객체 (데이터 그 자체)
    - 이 자바 클래스는 데이터베이스의 테이블과 일대일로 연결(매핑)
    - 이 어노테이션이 붙은 객체(엔티티)만이 영속성 컨텍스트에 의해 관리됨
- `@Repository`: 이 `Entity`를 DB에서 꺼내거나 저장하는 [창고 관리자] (접근 코드)
- `@Transactional`: 이 '창고 관리자'의 작업을 [안전하게 묶어주는] 장치 (안정성)
    - 이 메서드(혹은 클래스)에서 일어나는 모든 DB 작업은 하나의 묶음(트랜잭션)으로 처리됨
    - 성공 → 모든 작업 commit
    - 실패 → 단 하나의 작업이라도 실패한다면 모든 작업 Rollback
    - 이 어노테이션이 붙은 메서드가 시작될 때  속성 컨텍스트가 생성되고, 메서드가 끝날 때 영속성 컨텍스트가 종료

# 3주차 WIL

상품 추가와 구매 기능 코드를 구현하고 Swagger로 출력을 확인했는데 상품 개수의 변화가 업데이트가 안되는 문제점을 발견했다. 스프링 데이터 JPA에서 데이터를 수정하거나 삭제 할 때는 반드시 해당 메서드에 트랜잭션 처리가 되어 있어야한다는 점을 새로 알게 되었고  @Transactional 어노테이션을 통해 변경 감지 기능을 활성화 하여 문제를 해결하였다. @Transactional 어노테이션이 없으면 데이터 수정 시 자바 프로그램 안에서만 숫자가 바뀌고, 실제 데이터베이스에는 UPDATE 쿼리가 날아가지 않아서 저장이 안 되는 현상이 발생한다는 걸 새롭게 알게 되었다.

또한 같은 이름을 가진 상품(중복 상품)의 등록을 막기 위해 레포지토리 계층에 boolean existsByName(String name); 코드를 추가해서 서비스 계층에서 똑같은 이름을 입력받으면 예외처리를 할 수 있게끔 코드를 작성했다. 이와 관련해서 추가로 공부하면서 DB에서도 중복을 막아주는 @Column(unique = true)에 대해서도 알 수 있었다.

내가 미리 정해놓은 값을 다루는 코드가 아닌 임의의 값을 입력받아 이를 다루고 CRUD가 가능한 코드를 구현했다. 비즈니스 로직을 구현하는데 있어 많은 시간을 소모했지만, 새로운 어노테이션과 계층 간 역할에 대해서 더 자세하게 알 수 있는 한 주였다